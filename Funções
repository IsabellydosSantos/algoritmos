Elementos de Funções

1. def 

· Função: Cria uma nova função para encapsular um bloco de código que pode ser reutilizado múltiplas vezes, organizando melhor o programa e evitando repetição.

Exemplo: 

def calcular_area(largura, altura):
    area = largura * altura
    return area

# Chama a função quando precisar do cálculo
resultado = calcular_area(5, 3)

print(resultado)  # Output: 15


2. Argumentos/Parâmetros

São variáveis que recebem valores externos para serem usados dentro da função.

· Função: Permitem que a função trabalhe com dados diferentes a cada chamada, tornando-a flexível e reutilizável.

Tipos de Argumentos:

Argumentos Posicionais

# Os valores são atribuídos na ordem dos parâmetros
# Usado quando a ordem dos argumentos é fixa e conhecida

def criar_email(nome, sobrenome, dominio):
    return f"{nome}.{sobrenome}@{dominio}"

# Os valores são passados na ordem: nome, sobrenome, dominio
email = criar_email("joao", "silva", "gmail.com")

print(email)  # Output: joao.silva@gmail.com


Argumentos Nomeados 

# Os valores são atribuídos pelo nome do parâmetro
# Usado quando queremos ser explícitos ou mudar a ordem padrão

def criar_pessoa(nome, idade, cidade):
    return f"{nome}, {idade} anos, de {cidade}"

# É possível mudar a ordem usando os nomes dos parâmetros
pessoa1 = criar_pessoa(nome="Maria", cidade="São Paulo", idade=25)
pessoa2 = criar_pessoa(cidade="Rio", idade=30, nome="Carlos")

print(pessoa1)  # Output: Maria, 25 anos, de São Paulo
print(pessoa2)  # Output: Carlos, 30 anos, de Rio


Valores Padrão 

# Define um valor inicial para parâmetros opcionais
# Usado para tornar alguns argumentos opcionais na chamada da função

def cumprimentar(nome, saudacao="Olá", pontuacao="!"):
    return f"{saudacao}, {nome}{pontuacao}"

# Podemos omitir os parâmetros com valores padrão
print(cumprimentar("Ana"))                    # Output: Olá, Ana!
print(cumprimentar("Pedro", "Oi"))           # Output: Oi, Pedro!
print(cumprimentar("João", "E aí", "?"))     # Output: E aí, João?


3. *args (Argumentos Arbitrários)

· Função: Permite que a função receba um número variável de argumentos posicionais. O * transforma os argumentos em uma tupla.

# Usado quando não se sabe quantos argumentos a função vai receber, ou quando é necessário uma função flexível que aceite múltiplos valores.

# *args captura todos os argumentos posicionais em uma tupla
# Usado em funções que precisam lidar com quantidade variável de dados

def somar_numeros(*args):
    """
    args vira uma tupla com todos os argumentos passados
    Exemplo: se chamar somar_numeros(1, 2, 3), args será (1, 2, 3)
    """
    print(f"Args recebido: {args}")  # Mostra a tupla criada
    total = 0
    for numero in args:
        total += numero # Percorre cada número na tupla e soma ao total

    print(f"Resultado: {total}")
    
    return total

# Usos:
print(somar_numeros(1, 2))           # Output: Args recebido: (1, 2), Resultado: 3
print(somar_numeros(1, 2, 3, 4, 5))  # Output: Args recebido: (1, 2, 3, 4, 5), Resultado: 15
print(somar_numeros(10))             # Output: Args recebido: (10,), Resultado: 10

# Exemplo: Criar lista de compras
def lista_compras(*itens):
    print("Itens para comprar:")
    for i, item in enumerate(itens, 1):  # A função enumerate() pega a tupla itens e numera cada elemento. O "1" no final faz com que a contagem comece do índice 1 em vez do 0.
        print(f"{i}. {item}")  # Para cada iteração do loop, i recebe o índice (posição) e item recebe o valor.

lista_compras("pão", "leite", "ovos", "café")
# Output:
# Itens para comprar:
# 1. pão
# 2. leite
# 3. ovos
# 4. café


4. **kwargs (Argumentos de Palavra-chave Arbitrários)

· Função: Permite que a função receba um número variável de argumentos nomeados. O ** transforma os argumentos em um dicionário.

# Usado para que a função aceite configurações opcionais ou parâmetros com nomes arbitrários.

# **kwargs captura todos os argumentos (pares chave-valor) nomeados em um dicionário
# Usado em funções que precisam de muitas configurações opcionais

def criar_perfil(**kwargs):
    """
    kwargs vira um dicionário com todos os argumentos nomeados
    Exemplo: criar_perfil(nome="Ana", idade=25) → kwargs = {'nome': 'Ana', 'idade': 25}
    """
    print(f"Dados recebidos: {kwargs}")

# Usos:
print(criar_perfil(nome="Maria", idade=30))
# Output:
# Dados recebidos: {'nome': 'Maria', 'idade': 30}

print(criar_perfil(nome="João", profissao="Engenheiro", cidade="SP", pais="Brasil"))
# Output:
# Dados: {'nome': 'João', 'profissao': 'Engenheiro', 'cidade': 'SP', 'pais': 'Brasil'}

# Exemplo: Configuração de conexão com banco de dados
def conectar_banco(**config):
    """Conecta ao banco com configurações flexíveis"""
    host = config.get('host', 'localhost')  # Valores padrão se não existir são "localhost:5432 como admin"
    porta = config.get('porta', 5432)
    usuario = config.get('usuario', 'admin')
    
    print(f"Conectando em {host}:{porta} como {usuario}")
    # Conexão real iria aqui...

conectar_banco(host="meuservidor.com", porta=3306)
# Output: Conectando em meuservidor.com:3306 como admin

conectar_banco(host="192.168.1.1", usuario="root", senha="123456", banco="clientes")
# Output: Conectando em 192.168.1.1:5432 como root


5. return - Retorno de Valores

· Função: Encerra a execução da função e devolve um valor

# Usado para que a função possa produzir um resultado que pode ser usado em outras partes do programa.

# Transfere um valor de volta para o código que chamou a função
# Usado para obter resultados de processamentos feitos na função

def calcular_imc(peso, altura):
    imc = peso / (altura ** 2)
    return imc  # Devolve o resultado do cálculo

# O valor retornado pode ser armazenado em variável
meu_imc = calcular_imc(70, 1.75)
print(f"Seu IMC é: {meu_imc:.2f}")

# Ou usado diretamente em expressões
if calcular_imc(80, 1.80) > 25:
    print("Acima do peso ideal")

# Função sem return retorna None
def apenas_imprime(mensagem):
    print(mensagem)
    # Não tem return → retorna None


6. Variáveis Locais vs Globais

Variáveis Locais

· Existem apenas dentro da função.

· Função: Isolar dados temporários que só são relevantes durante a execução da função.

Variáveis Globais

· Existem em todo o programa.

· Função: Compartilhar dados entre diferentes funções e partes do programa.

# Variável global
contador_global = 0

def incrementar_local():
    # Variável local - só existe dentro dessa função 
    contador_local = 0
    contador_local += 1
    return contador_local
# Toda vez que a função é chamada, a variável local reinicia do zero, logo o resultado será sempre 1

def incrementar_global():
    # Para modificar variável global, é preciso declarar
    global contador_global
    contador_global += 1
    return contador_global
# Toda vez que a função é chamada, a variável global é alterada, armazenando um novo valor

# Exemplo
print("Locais:", incrementar_local())  # Output: 1
print("Locais:", incrementar_local())  # Output: 1 (sempre reinicia)

print("Globais:", incrementar_global())  # Output: 1
print("Globais:", incrementar_global())  # Output: 2 (mantém o valor)

